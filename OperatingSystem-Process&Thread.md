## 进程
- 进程是具有单独功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位
- 对CPU的抽象
- 又称任务
- 系统资源以进程为单位，分配，如内存、文件、每个具有独立的地址空间
- 操作系统将CPU调度给需要的进程
### 进程控制块 PCB
- Process Controll Block
- 操作系统用于管理控制进程的一个专门数据结构
- 记录进程的各种属性，描述进程的动态变化过程
- pcb是系统感知进程存在的唯一标志
  - 进程与PCB 一一对应
- 进程表：所有进程的PCB集合

#### PCB应该包含什么内容
##### 进程描述信息
- 进程描述符ID，唯一，通常整数
- 进程名
- 标识符
- 进程组
- 状态
- 优先级
- ……
##### 进程的资源和使用情况
##### CPU现场信息

### 进程的三种基本状态
- 运行态
  - 正在CPU上运行
- 就绪态
  - 万事俱备，只欠CPU
- 等待态（阻塞态 封锁态 睡眠态）
  - 因等待某一事件而暂时不能运行
#### 状态转换
- 运行-》就绪
  - 用完时间片 变成就绪态
  - 高优先级进入
- 运行-》等待
  - 请求服务
  - 对资源访问尚且不能进行
  - 等待io
- 等待-》就绪
  - 所等待的事情发生了
#### 其他状态
- 创建
  - 已完成创建
  - 尚未同意执行该进程
- 终止
  - 终止执行后
  - 可以来完成一些数据统计工作
  - 资源回收
- 挂起
  - 用于调节负载
  - 进程不占用内存空间
### 进程队列
- os为每一类进程建立一个或多个队列
- 队列元素为PCB
- 伴随进程状态的改变，其PCB从一个队列进入另一个队列
### 进程控制
- 进程控制操作完成进程各状态之间的转换，由具有特定功能的**原语**完成
  - 原语：完成某种特定功能的一段程序，具有不可分割性或不可中断性 原子操作
  - 进程创建原语
  - 进程撤销原语
  - 阻塞原语
  - 唤醒原语
  - 挂起原语
  - ……
#### 进程的创建
- 给新进程分配一个唯一标识以及进程控制块
- 分配地址空间
- 初始化PCB
- 设置相应的队列指针
- UNIX中进程创建主要是fork和exec配合使用
- windows是CreateProcess
#### 进程的撤销
- 结束进程
  - 回收进程所占有的资源
    - 关闭文件，断开连接
  - 撤销该进程的PCB
- UNIX :exit
- windows：TerminateProcess
#### 进程的阻塞
- 处于运行状态的进程，若期待某一事件发生，e.g 键盘输入 当被等待的事件未发生时，由进程自己执行阻塞原语，使自己由运行态变为阻塞态
- unix：wait
- windows：WaitForSingleObject
#### UNIX的几个进程控制操作
- fork 通过复制调用进程来建立新的进程，是最基本的创立进程的过程
- exec() 包括一系列系统调用，它们都是通过用一段新的程序代码覆盖原来的地址空间，实现进程执行代码的转换
- wait 初级的进程同步操作，是一个进程等待另一个进程的结束
- exit 终止进程
- 以上都是系统调用的形式
##### unix 的fork实现
- 为子进程分配一个空闲的进程描述符
  - proc结构
- 分配给子进程唯一标识PID
- **一次一页的方式** 把父进程的地址空间内容完全拷贝给子进程
- 从父进程哪里继承共享资源，打开的文件啥的
- 子进程设置为就绪状态，插入就绪队列
- 对子进程返回标识符0
- 向父进程返回子进程pid
##### unix 的fork实现
- 而linux使用Copy On Write （写时复制）来加快创建进程
- 原来是复制父进程地址空间，现在是给父进程的地址空间指针，并且设置为只读
- 只有在往里面写入的时候，写时复制，操作系统才会开辟一块新空间，新内容放进去
![](https://i.loli.net/2020/02/11/sk9oby5IfH7R8eV.png)
![](https://i.loli.net/2020/02/11/T9nEXphOBVi3be1.png)
#### 进程的分类
- 系统进程
  - 优先级比较高
- 用户进程
或
- 前台进程
- 后台进程
或
- CPU密集型进程
- I/O密集型进程

#### 进程的层次结构
- unix进程家族：init为根
- windows：地位相同
#### 进程映像
- 对进程执行活动全过程的静态描述
- 用户相关
- 寄存器相关
- 内核相关
#### 上下文切换
- 将CPU硬件状态从一个进程换到另一个进程的过程称为上下文切换
- 进程运行时，其硬件状态保存在CPU上的寄存器中
- 进程不运行时，这些寄存器的值保存在进程控制块PCB中，当操作系统要运行一个新的进程时，将PCB中的相关值送到对应的寄存器中
## 线程
- 用户级线程
- 混合级线程
- 两者混合
### 用户级
- 在用户空间建立线程库
- 运行时系统，完成线程的管理工作
- 内核管理的还是进程，不知道线程存在
- 线程切换不需要内核特权
- 例子：unix
- 例如：POSIX线程库
  - POSIX（Portable Operating System Interface)
  - 多线程变成接口，以线程库方式提供给用户
  - 重点介绍yield
    - 自愿让出CPU
- 优点
  - 线程切换快
  - 调度算法是应用程序特定的
  - 用户级线程可运行在任何操作系统上（只需要实现线程库）
- 缺点
  - 内核只将处理器分配给进程，同一进程中的两个线程不能同时运行于两个处理器上
  - 大多数系统调用是阻塞的，因此，由于内核阻塞进程，故进程中所有线程也被阻塞
### 核心级线程
- 内核管理所有线程管理，并向应用程序提供API接口
- 内核维护进程和线程的上下文
- 线程的切换需要内核支持
- 以线程为基础进行调度
- 例子：windows
### 混合模型
- 线程创建在用户空间完成
- 线程调度在核心态完成
- 例子：Solaris
- 多个用户级线程多路复用多个内核级线程
### 总结
![](https://i.loli.net/2020/02/12/zcgQpf92rWnSXua.png)
### tips 可再入程序（可重入）：
- 可被多个进程同时调用的程序，具有以下性质：
  - 纯代码
  - 在执行过程中自身不改变
  - 调用它的进程应该提供数据区
